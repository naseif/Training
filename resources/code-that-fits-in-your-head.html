<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Continuous Developer Training - Resources</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    li {
      margin-bottom: 1em;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-light" style="background-color: #e3f2fd;">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">Continuous Developer Training - Resources</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarText"
        aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarText">
        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="index.html">back to resources</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container mt-2">
    <h1>Code That Fits in Your Head <small class="text-muted"> Heuristics for Software Engineering</small></h1>

    <p>
    <table class="table">
      <tr>
        <th>Authors</th>
        <th>published</th>
        <td>Link</td>
      </tr>
      <tr>
        <td>Mark Seemann</td>
        <td>2022</td>
        <td><a href="https://www.amazon.de/s?k=Code+That+Fits+in+Your+Head">Find the book here</a></td>
      </tr>
    </table>
    </p>

    <br>
    <h2>Summary</h2>
    <p>The book focusses on two areas, that are mixed up in the content:</p>
    <ul>
      <li><mark>How to keep code simple and easy to comprehend?</mark><br />
        Starting from the things that we know about how our brain works, what does simple mean and how can we see and
        improve on that?
      </li>
      <li><mark>How to get away from the shifting sands of individual experience?</mark><br />
        We software developers are dominated by our own individual experiences heavily. That hinders team work. So what
        practices can we lend and modify from engineering to achieve more conformity?
      </li>
    </ul>

    <hr>
    <h4>Chapter 1: Art or Science?</h4>

    <p>The author lists different analogies that are usually used when trying to explain what software development is,
      like: Building a house, growing a garden, crafting and more. </p>
    <p>
      He shows that, while all of them contain some truth,
      none fits right. But for the moment <mark>software engineering</mark> seems right for him and he wants to
      contribute something
      in this direction.</p>

    <hr>

    <h4>Chapter 2: Checklists</h4>

    <ul>
      <li><mark>Use checklists</mark><br>
        They are easy to create and can help everybody on the team. In a lot of different complex jobs they
        already help a lot.
      </li>
    </ul>

    <hr>

    <h4>Chapter 3: Tackling complexity</h4>

    <p>
      Software engineering is about tackling complexity. <mark>The brain works in certain ways, e.g. we can only keep track of
      7 things in our short term memory. Our code needs to respect that.</mark>
    </p>

    <hr>

    <h4>Chapter 4: Vertical Slice</h4>

    <p>Instead of working your way from the UI down to the database or the other way round, consider creating a vertical slice.</p>
    <p>A vertical slice contains everything from the ui down to the database. It means that you only implement one feature, but through your complete architecture.</p>
      
    <p>This has advantages:</p>

    <ul>
      <li><mark>You create working software</mark><br>
        You can already get user feedback on it. Maybe the users can even already use it for a certain part of their work?
      </li>
      <li><mark>You can already test drive your CI/CD pipelines</mark><br>
        ... and they start small, so it should be easier to create them early.
      </li>
    </ul>

    <p>This vertical slice can also be described by the name of "walking skeleton" (<a href="https://lazaroibanez.com/management-walking-skeleton-the-simple-prioritization-technique-for-mvps-5d99490dad59" target="_blank">external explanation)</a>.</p>

    <p>Then <mark>use outside-in test-driven development</mark>:</p>

    <ul>
      <li><mark>start with a characterization test</mark><br>This is a high level test that describes a functionality.</li>
      <li><mark>From there on write more tests and code to complete the functionality</mark><br>... , working your way inward on the details.</li>
    </ul>

    Other recommendations are:
    <ul>
      <li><mark>Test code should be in balance</mark><br>
        When you turn the code 90 degrees and then point to the middle you should
      point to the act section (this essentially means that the arrange and assert blocks should have about equal
      length).
      </li>
      <li><mark>Documentation should prioritise explaining <em>why</em> a descision was made</mark><br>
        ..., rather than <em>what</em> was decided.
      </li>
      <li><mark>Use value objects</mark><br>
        This makes the Domain Model easier and easier to test (Example given on Page 71). Since they are not complicated and often also fully implemented by a tool, the error probability is very low. Thus you do not need to write tests for them.</li>
      <li><mark>Commit database schema to the Git repository.</mark></li>
      <li><mark>Remove internal logic from classes that interact with subsystems to the utmost extend so you do not have much that could fail.</mark><br>Classes that interact with subsystems are not easily tested.</li>
    </ul>

    <hr>

    <h4>Chapter 5: Encapsulation</h4>

    <ul>
      <li><mark>Encapsulation</mark><br> is about being able to trust an object to behave in a certain way. So it is good to reduce complexity.</li>
      <li><mark>Write production code as answer to drivers</mark><br/> like tests or analyzers.</li>
      <li><mark>Keep the time your code is invalid as short as possible.</mark><br> Concept: Transformation Priority Premise</li>      
      <li><mark>Postel's law</mark><br> "Be conservative in what you send, be liberal in what you accept."</li>
      <li><mark>"The most important notion is that an object should guarantee that it'll never be in an invalid state."</mark><br>
        (p.108)</li>
      <li><mark>"The less you ask of the caller, the easier it is for the caller to interact with the object. The better
        guaranties you give, the less defensive code the caller has to write."</mark><br> (p.109)</li>
    </ul>

    <h4>Chapter 6: Triangulation</h4>
    <ul>
      <li><mark>Do not count on your long term memory</mark><br/>
        Our long term memory it is not very valuable in a software development
        organization, neither for the long term value of developers nor for the company.<br><br>
        The developers collect information on legacy code. While this makes them
        hard to replace for one company it also renders them not valuable for any other 
        organisation and ultimatly restricts their personal development.<br><br>
        The company has increased bus factor problems, because the developers on a project 
        are not easily replaced. This also restricts scaling, keeping the software operational,
        and might be a kill switch, if the company is to dependent on the software.
      </li>
      <li><mark>Short development bursts</mark><br>
        While coding, when you see things that you want to change, make a list and keep to the change that you are
        doing at the moment. Do not get distracted.</li>
      <li><mark>Use the devil's advocate for writing unit tests</mark><br>
          It is a technique where you continue to try to implement a clearly wrong solution that still makes all tests
          pass. Then you try to be more specific in your tests and continue this loop until your tests are so good 
          that they force you to implement the right thing.
      </li>
    </ul>

    <h4>Chapter 7: Decomposition</h4>
    <ul>
      <li><mark>Continuously watch your code complexity</mark><br> Code increases in complexity over time and it is a bad habit to leave it unchecked.</li>
      <li><mark>Cyclometic complexity</mark><br>
         could be monitored by a build system. (Counts the number of branching and looping
        instructions). You should strive for less than 7.</li>
      <li><mark>80x24 rule</mark><br> based on the constraints of early terminals, the code of a method should fit these constraints
      </li>
      <li><mark>Parse, don't validate</mark><br> 
        Using the TryParse-Methods in the .Net library reduces the complexity</li>
      <li><mark>Fractal architecture</mark><br> 
        At every level your architecture should not exceed a maximum of 7 elements. 
        This will span a tree and still be within some bounds to be comprehensible by your brains constraint.</li>
      <li>
        <mark>Variable count</mark><br> 
        The number of variables and parameters your method uses should be kept below or equal to 7.</li>
    </ul>

    <h4>Chapter 8: API design</h4>
    <ul>
      <li><mark>Dot-Driven Development</mark><br>
        This means supporting Intellisense so that users can quickly find what they are looking for.
      </li>
      <li><mark>Poka-Yoke</mark><br> 
        Fool-proof your api by making mistakes impossible by design. 
        Compiler-errors are preferable to runtime errors.</li>
      <li><mark>Remember to write for <i>readers</i></mark></li>
      <li><mark>Favor well-named code over comments</mark></li>
      <li><mark>Can you create self-explaining signatures?</mark>
        <br>Try to x-out names of methods and then try to infer the name from the signature. 
        You may be able to shorten the name since you do not have to say what the types already state.</li>
      <li><mark>Use Command-Query-Separation</mark><br>
        Methods that return data should not have side effects.<br> 
        Methods with side effects should not return data.</li>
      <li><mark>Use the Hierarchy of Communication</mark><br/><ol>
          <li style="margin:0">give APIs distinct types</li>
          <li style="margin:0">give methods helpful names</li>
          <li style="margin:0">write good comments</li>
          <li style="margin:0">provide illustrative examples as automated tests</li>
          <li style="margin:0">write helpful commit messages in git</li>
          <li style="margin:0">write good documentation</li>
        </ol>
        Prefer the methods with the lower number, when having a choice.
      </li>
    </ul>

    <h4>Chapter 9: Teamwork</h4>

    <span class="fw-bold">Teamwork is one of the most engineering-like practices you can adopt.</span>

    <ul>
      <li><mark>Use the 50/72-rule for git commit messages</mark>
        <ul>
          <li style="margin:0">write a summary in the <i>imperative</i> no wider than 50 characters</li>
          <li style="margin:0">if you add more text, leave the second line blank</li>
          <li style="margin:0">you can add as much text as you'd like, but format it so that it's no wider than 72 characters</li>
        </ul> 
        You can then use <code>git log --oneline</code> to get a summary of the log while preserving detail.
        </li>
      <li><mark>Use continuous integration</mark><br>
        (merge at average every 4 hours, if your change 
        requires more time, hide it behind
        a feature flag and merge anyway)</li>
      <li><mark>small commits enhance manouverability</mark></li>
      <li><mark>collective code ownership</mark><br>
        A stable team does not exist, how many people can exit your team before the
        operation stops?</li>
      <li><mark>pair programming</mark><br> 
        comes with a real time code review and
        an informal approval process. It removes the time between 
        the development and the review effectivly countering the negative
        effects of late or no reviews.
      </li>
      <li><mark>mob programming</mark><br>
        Is effective in small groups, e.g. for coaching scenarios.
        <br>
        Remember: Productivity is unrelated to typing speed.
      </li>
    </ul>

    <h5>Code Reviews</h5>

        <ul>
          <li><mark>Review early</mark><br/>
            The longer the time between the coding and the code review the more time it will take because the
            developer forgets.</li>
          <li><mark>Review</mark><br/>
            Without reviews the probability of bugs in production increases, which are sometimes only found a long time
            after publishing,
            and then the dev will not remember his own code so fixing the bug will take even longer.
          </li>
          <li><mark>Reviews should be performed in at least a daily rhythm</mark></li>
          <li><mark>Reject big changesets</mark></li>
          <li><mark>Ask yourself: "Will I be ok maintaining this?"</mark></li>
          <li><mark>Driven by the reviewer</mark><br>
            code reviews should be driven by the reviewer, the developer is biased and is not in the position to tell
            if the code is readable.</li>
          <li><mark>Good questions for a code review</mark>
            <ul>
              <li style="margin: 0;">Does the code work as intended?</li>
              <li style="margin: 0;">Is the intent clear?</li>
              <li style="margin: 0;">Is there needless duplication?</li>
              <li style="margin: 0;">Could existing code have solved this?</li>
              <li style="margin: 0;">Could this be simpler?</li>
              <li style="margin: 0;">Are the tests comprehensive and clear?</li>
            </ul>
          </li>
          <li><mark>Absent author</mark><br>
            The author should be absent during the code reading, 
            the reviewer takes notes about what the people go
            into dialog later.</li>
          <li><mark>No privilege</mark><br>
            Code reviews should be conducted by all team members, 
            it is not a privilege for a selected few.</li>
        </ul>

        <h5>Pull Requests</h5>

        <ul>
          <li><mark>Make each pull request as small as possible.</mark><br>That's smaller than you think.</li>
          <li><mark>Do only one thing in each pull request.</mark><br> If you want to do multiple things, put them in separate pull
            requests.</li>
          <li><mark>Avoid reformatting</mark>
            <br> unless it is the only thing that you do in your pull request.</li>
          <li><mark>Make sure the code builds</mark></li>
          <li><mark>Make sure all tests pass</mark></li>
          <li><mark>Add tests of new behaviour</mark></li>
          <li><mark>Write proper commit messages</mark></li>
        </ul>
      </li>


    <br>
    <h3>Part 2 Sustainability</h3>
    <br />
    <h4>Chapter 10 - Augmenting Code</h4>

    <ul>
      <li><mark>Split up big changes into little changes</mark><br>
        For any significant change, don't make it in-place, make it side-by-side.
      </li>
      <li><mark>Use feature flags</mark><br>
        Feature flags can easily be used when you introduce a new functionality</li>
      <li><mark>Strangler-pattern on method level</mark>
        <ul>
          <li style="margin:0">do not start by modifying the interface rather by implementing & testing on a concrete object</li>
          <li style="margin:0">or do change the interface but only implement the new method in one concrete class - as long as you
            have no other consumers than tests</li>
        </ul>
        </li>
        <li><mark>Strangler-pattern on class level</mark><br>
          create a new class and move the implementation over step 
          by step</li>
      </li>
      <li><mark>Versioning</mark>
        <ul>
          <li style="margin:0">take advice from the semantic versioning specification to learn about breaking and nonbreaking changes
          </li>
          <li style="margin:0">warn users of your api when you have breaking changes</li>
        </ul>
      </li>
    </ul>
    <br/>
    <h4>Chapter 11 - Editing Unit Tests</h4>
    <ul>
      <li>
        <mark>Only edit either test or production code</mark>
        <br>When you edit the test code you have the risk that your test code breaks. This improves the chances to get it right.</li>
      <li><mark>Deleting assertions and tests weakens the integrity of the system.</mark></li>
      <li><mark>Automated refactorings are safe most of the time.</mark></li>
      <li><mark>Use the stash to get around merge problems at inappropriate times</mark><br>
        <code>git stash</code> : put all your dirty files in a hidden commit<br>
        <code>git stash pop</code> : reapply the stashed changes to HEAD as if they are new changes
      </li>
    </ul>

    <br>
    <h4>Chapter 12 - Troubleshooting</h4>

    <strong>What to do when your code does not work?</strong><br><br>
    <ul>
      <li><mark>The lowest level is programming by coincidence</mark><br>
        Throw code at a problem, look what sticks...<br>
        This is not recommended.
      </li>
      <li><mark>The Scientific Method</mark>
        <ul>
          <li style="margin: 0;">make a hypothesis</li>
          <li style="margin: 0;">perform the experiment</li>
          <li style="margin: 0;">compare outcome to prediciton repeat until you understand what is going on.</li>
        </ul>
      </li>
      <li><mark>Simplify code</mark></li>
      <li><mark>Rubber Ducking</mark><br> 
        explain the problem to a collegue or a rubber duck. 
        You can do this in writing to, e.g. as an email. At the end you can decide if you still need to send it.</li>
      <li><mark>Address defects early</mark><br>
        Do not schedule solving known defects for later, as they probably will cause secondary and 
        tertiary effects that will create additional work</li>
      <li><mark>Reproduce defects as tests</mark><br>
        If a defect occurs once it has already proven that it can occur. Creating an automated test 
        that reproduces the problem will help you not only fixing it but also protect you against a second occurence.
      </li>
      <li><mark>Do not be afraid of slow tests</mark><br>
        Use slow tests, but when they take more than 10 seconds let them be run by a second system, maybe your build system.<br>
      </li>
      <li><mark>Reproduce nondeterministic defects with loops</mark><br/>
        Nondeterministic defects e.g. race conditions cannot be 100% tested. But you can 
        create tests that make the problem probable and then loop over them for a few minutes.
        If you get away with a green flag you then can be relativly certain that you addressed the 
        problem.</li>
      <li><mark>Use Bisection</mark>
        <ol>
          <li style="margin: 0;">Find a way to detect or reproduce the problem</li>
          <li style="margin: 0;">remove half of the code</li>
          <li style="margin: 0;">If the problem is still present, repeat from step 2. If the problem goes away, restore the code you removed, and remove the other half. Again repeat from step 2.</li>
          <li style="margin: 0;">Keep going until you've whittled down the code that reproduces the problem to a size so small that you
            understand what is going on.</li>
        </ol>
      </li>
      <li><mark>Use Bisection using GIT</mark><br>
        Walk back in the history to identify the commit that introduced the bug; git has a <code>git bisect</code>
        command to explicitly help with this interactivly using a search algorithm.</li>
    </ul>

    <h4>Chapter 13 - Separation of Concerns</h4>
    <ul>
      <li><mark>Nesting is bad</mark><br>
        Hidden side effects can easily make your code less comprehensible.</li>
      <li><mark>Sequencial combination is good</mark></li>
      <li><mark>Pure functions reduce the complexity</mark><br> 
        Pure functions are only dependent on their parameters, not external side-effects.
        This also makes them very testable.
      </li>
      <li><mark>Keep side effects close to the edges of the system</mark><br/>
        Keep nondeterministric queries and behaviour with the side effects close to the edges of the system and write
        complex logic as pure functions.</li>
      <li><mark>Use decorators for cross cutting concerns</mark><br>
        (e.g. Logging, Performance Monitoring, Auditing, Metering, Instrumentation, Caching, Fault Tolerance
        and Security)</li>
      <li><mark>Log all impure actions, but not more</mark><br>
        You log the right amount of information when you can repeat the execution.
      </li>
      <li><mark>Try "functional core, imperative shell" as coding style</mark></li>
    </ul>

    <h4>Chapter 14 - Rhythm</h4>

    <strong>Personal rhythm:</strong>

    <ul>
      <li><mark>Use boxes of time</mark></li>
      <li><mark>Do breaks</mark></li>
      <li><mark>Break out of the flow</mark><br>
        In the state of flow you can easily waste hours, because you do not have enough capacity left to 
        know if you are working on the right things. Remember that intellectual work is not about the hours 
        you put in. <mark>Use time deliberatly!</mark>
      </li>
      <li><mark>Learn touch typing</mark><br>
        so you can look at the screen while typing and can use all the features modern IDEs give you
      </li>
    </ul>

    <strong>Team Rhythm:</strong>
    <ul>
      <li><mark>Update dependencies regularily</mark>
        <br>... so you do not get stuck on old library versions (recommended once per month)</li>
      <li><mark>Schedule maintenance tasks</mark></li>
    </ul>

    <h4>Chapter 15 - The Usual Suspects</h4>

    <ul>
      <li><mark>Correctness is more important than performance</mark><br>
        If the program does not need to work correctly, you can always make it run faster. 
        Correctness should be the center of your attention.</li>
      <li><mark>If you need to work on performance, then measure it.</mark><br>
        You cannot work on performance without measuring it!
        </li>
      <li><mark>Use the STRIDE acronym to think about security</mark><br>
        Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, Elevation of privilege</li>
      <li><mark>Try property-based testing</mark><br />
        Mark a test as [Property] and running it using FsCheck. FsCheck auto-generates the parameters for the test method
        It is like [TestCase], just random.</li>
      <li><mark>Use Behavioural Code Analysis</mark><br /> 
        reasoning over your git log, which files seem to be involved in most changes, which
        "cause the most trouble"? (This is an own research topic).</li>
    </ul>

    <h4>Chapter 16</h4>
    <ul>
      <li><mark>Put all files in one folder</mark><br>
        "When you put a file in one folder you cannot put it into another folder at the same time."</li>
      <li><mark>Use IDE features to navigate</mark><br>
      Instead of a folder structure</li>
      <li><mark>Avoid cyclic dependencies in your code</mark></li>
    </ul>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.min.js"></script>
</body>

</html>