# Projects

I want to have a long term relationship with the ideas that I have and implement as software.
This way I retain the freedom of reimplementing everything in a different techstack and develop training material additionally to the more standard effect of suddenly have a program that I would like to have. After all, sooner or later, everything changes again. Only the requirements stay.

## A project is to big for today?

The projects in this repository are not designed with duration in mind. I meank not at all. Most are based on something that I want to have and took the time of at least writing down what I would like. 
Although there are a few that you can finish in less than in hour there are also several that can take a week or more. Even longer depending on what you want to achieve. After all it is not just about implementing but about reimplementing in other ways and learning this way what would be better in a surrounding that pays you for the job.

If a project is too big for today, you might exercise with these other things:

- https://www.hackerrank.com/ 

## Naming convention for repositories

This is not a must, but I recommend it when you find yourself implementing the projects more often and want to retain a certain overview in your github. I certain,y use it.

I recommend the following structure for naming your repositories:
 - first the project Id: Pxxx
 - then the project type you are going for: Console, WebApp, WebApi, GUI, Library ...
 - then the operating system you are going for: Win32, Win64, Linux, MacOS, X (x=cross platform)
 - then the name of the programming language or stack you want to use: C, CSharp, JavaScript, Python...
 - optionally followed by a 3 digit number which is the iteration
and all seperated by hyphens

examples: 
- P001-Console-Linux-C
- P001-Console-Linux-C-002 
- P001-Console-Linux-CSharp
- P001-GUI-Win64-CSharp

This might make my repositories a little bit less readable, unless you know what you are looking for. Nontheless it is a more structured approch and it really makes sense in the grand scope of things.

## The challenge descriptions

- [P001](P001/README.md) - A random stuff generator ( [C](https://github.com/stho32/P001-Console-Linux-C), [CSharp](https://github.com/stho32/P001-Console-Linux-CSharp),  [Rust](https://github.com/stho32/P001-Console-Linux-Rust) )
- [P002](P002/README.md) - Grab a random saying and make the app read it out loud for you
- [P003](P003/README.md) - Implement a dice game
- P004 - Create a game of Tic-Tac-Toe complete with an AI you can play against
- P005 - Create a vocabulary trainer that supports a diverse set of different question types and learning methods
- P006 - Create a tool to record your working time
- P008 - Create a network chat application
- P009 - Create a documentation software
- P010 - Create a task management application with a kanban like view
- P011 - Create an app that helps you buy the right ingredients for a set of meals you want to eat
- P012 - Take a course in discrete math ðŸ˜ƒ
- [P013](P013/README.md) - Write an app that can solve sodoku riddles
- [P021](P021/README.md) - "mailrules" an imap based email rule engine with your own spam filter
- [P022](P022/README.md) - "code2json" a scanner/parser that will convert your code to easily processable json for analytics
- [P023](P023/README.md) - "ArgLang" A library to parse command line arguments as if they would be routes
- [P024](P024/README.md) - "bld" A generic build script, that autodetects the contents of the repository / directory
- [P025](P025/README.md) - "dpl" A deployment infrastructure for continuous deployment
- [P026](P026/README.md) - "cld" A tool to manage virtual machines

## additional ideas to make the training more effective and fun

- Remove your mouse from the computer. Let us see if you are good enough to do the challenge keyboard only.
- Implement the same project multiple times. Measure the time needed. In every iteration try to finish in half the time.
